<!DOCTYPE html>
<html>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"> </script>
<script src="https://requirejs.org/docs/release/2.3.5/minified/require.js"> </script>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>canvas</title>
	<style type="text/css">
		html,body{
			height: 100%;
			padding: 0px;
			margin:  0px;
		}

		#xp{
			border: none;
			padding: 3px;
		  outline: none;
		  font-size: 20px;
			text-align: center;
		}

		input[type="text"]::placeholder { text-align: center; }
	</style>

	<script>
    async function loadModel() {
      model = undefined;
			url = "https://raw.githubusercontent.com/SXCSEM6-project/ModelStore/main/model.json"
      model = await tf.loadLayersModel(url);
      console.log("model loaded")
			//console.log(model.summary())
    }
		loadModel()

		const imgSz = 32
		var xp = '' //stores expresion
	</script>
</head>
<body>
	<p id="imgRd" style="display: none;"></p>
	<br>
	<center>
		<p><br><input id="xp" type="text" size="20" readonly placeholder="Result">
			<br><br></p>

		<canvas width="1000" height="400" id="c" style="border: 2px solid black;" align="center"></canvas>

		<br>
		<p><button onclick="getImg()">CLICK</button>
		&emsp;<button onclick="clrCnv()">CLEAR</button>
		</p>
	</center>
	<script type="text/javascript">
		const canvas = document.getElementById("c");
		const context = canvas.getContext("2d");
		context.fillStyle = "white";
		context.lineWidth = 15;
		context.fillRect(0, 0, canvas.width, canvas.height);
		canvas.addEventListener("mousedown", (event)=>{
			context.beginPath();
			context.moveTo(event.offsetX, event.offsetY);
			canvas.addEventListener("mousemove",draw,false)
		}, false)
		canvas.addEventListener("mouseup", (event)=>{
			canvas.removeEventListener("mousemove",draw,false);
		}, false);

		document.body.addEventListener("mouseup", (event)=>{
			canvas.removeEventListener("mousemove",draw,false);
		}, false);

		const draw = function(event){
			context.lineTo(event.offsetX, event.offsetY);
			context.moveTo(event.offsetX, event.offsetY);
			context.stroke();
		}

		function getImg()
		{
			console.clear();
			convert().then(function(res) {
				//console.log(res)
				document.getElementById('imgRd').innerHTML = res
				var l = document.getElementById("imgRd").childElementCount;
				var img = document.getElementById(`img${l-1}`)
				img.onload = function() {
					xp = ''
					for(let i=0;i<l;i++) {
						var img = document.getElementById(`img${i}`)
						console.log(img.id);
						imgT = tf.browser.fromPixels(img,1);
						// console.log(imgT)
						read(imgT)
					}
					document.getElementById("xp").value=xp
				}
				//console.log(l)
				// for(let i=0; i<l; i++)
				// {
				// 	// var c = document.getElementById(`cnv${i}`);
				//   // var ctx = c.getContext("2d");
				// 	// var img = new Image();
				// 	// img.onload = function() {
				// 	//     ctx.drawImage(this, 0, 0);
				// 	// 		// imgT = tf.browser.fromPixels(this);
				// 	// 		// console.log(imgT)
				// 	//     // call next step in your code here, f.ex: nextStep();
				// 	// };
				// 	// img.crossOrigin = "Anonymous";
				// 	// img.src = document.getElementById(`img${i}`).value;
				//   var img = document.getElementById(`img${i}`);
				// 	// img.width = imgSz
				// 	// img.height = imgSz
				//   // ctx.drawImage(img, 0, 0);
				// 	img.onload = function() {
				// 		console.log(img.complete)
				// 		// stopCount()
				// 		// imgT = tf.browser.fromPixels(img,1);
				// 		// console.log(imgT)
				// 		// read(imgT)
				// 		// tf.browser.toPixels(imgT,c)
				// 	}
				// 	// startCount()
				// 	console.log('hi')
				// }
			}).catch (function(err) {
		   	console.error(err);
		  });
		}

		function read(img)
		{
			// img = tf.browser.fromPixels(canvas, 1) // reads image from canvas
			// pred = tf.tensor( [ img.arraySync() ] )
			// pred = tf.scalar(255).sub(img)
			pred = img.div(tf.scalar(255))
			v = model.predict( tf.tensor( [ pred.arraySync() ] ) )
			res = tf.tensor( v.dataSync() ).argMax().dataSync()
			console.log( res[0] )
			xp+=res[0];
			// tf.browser.toPixels(pred,canvas) // prints read image to canvas
			// console.log( tf.tensor( [ pred.arraySync() ] ) )
		}

		function clrCnv()
		{
			context.clearRect(0, 0, canvas.width, canvas.height);
			context.fillStyle = "white";
			context.lineWidth = 15;
			context.fillRect(0, 0, canvas.width, canvas.height);
		}

		const convert = function()
		{
			return new Promise(function(resolve, reject){
			let png = canvas.toDataURL("image/png")
			var msg = JSON.stringify(png);
			//console.log(msg)
   			var xhr = new XMLHttpRequest();
   			// console.log(xhr.open('POST',"/convert",true));
				xhr.open('POST',"/convert",true)
				xhr.onload = (res) => {
					// console.log(res['target']['response']);
        	srvRes = res['target']['response'];
					// document.getElementById('imgRd').innerHTML = message;
					// getImg()
					resolve(srvRes)
				};
				xhr.send(msg);
   			alert('file is saved');
		});
	}
	</script>
</body>
</html>
